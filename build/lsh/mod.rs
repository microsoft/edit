//! This file takes a [`LanguageDefinition`] which describes syntax highlighting rules
//! for a language via a list of regular expressions that result in
//! * a highlight kind (comment, string, number, etc.)
//! * a push/pop action of another state (allows for nesting languages, such as in Markdown)
//!
//! It then transforms the definition into a list of [`WipState`], which are directions
//! to our custom DFA engine. The engine is very simple to reduce binary size.
//! Each defined state represents a root. Each additional state represents one step in
//! the regular expression. The difference between the two is that the root states will
//! seek to the next possible occurrence of any of the defined regular expressions,
//! whereas the additional states will try to match the next character without seeking.
//! If it doesn't match, it will fall back to the next possible defined regular expression.

mod definitions;
mod handles;
mod transformer;

use std::fmt::Write as _;

use definitions::*;
use transformer::*;

pub fn generate() -> String {
    let mut output = String::new();

    output.push_str(
        "\
// This file is generated by build.rs. Do not edit it manually.

use Action::*;
use HighlightKind::*;
use Test::*;

pub struct Language {
    pub name: &'static str,
    pub filenames: &'static [&'static str],
    pub transitions: &'static [Transition<'static>],
}

impl PartialEq for Language {
    fn eq(&self, other: &Self) -> bool {
        std::ptr::eq(self, other)
    }
}

pub struct Transition<'a> {
    pub test: Test<'a>,
    pub kind: Option<HighlightKind>,
    pub action: Action,
}

pub enum Test<'a> {
    Chars(usize),
    Charset(&'a [u16; 16]),
    Prefix(*const u8),
    PrefixInsensitive(*const u8),
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum HighlightKind {
    Black,
    Red,
    Green,
    Yellow,
    Blue,
    Magenta,
    Cyan,
    White,
    BrightBlack,
    BrightRed,
    BrightGreen,
    BrightYellow,
    BrightBlue,
    BrightMagenta,
    BrightCyan,
    BrightWhite,

    Other,
    Comment,
    Number,
    String,
    Variable,
    Operator,
    Keyword,
    Method,
}

pub enum Action {
    Jump(u8),
    Push(u8),
    Pop(u8),
    Loop(u8),
}

const fn t<'a>(test: Test<'a>, kind: Option<HighlightKind>, action: Action) -> Transition<'a> {
    Transition { test, kind, action }
}

",
    );

    for lang in LANGUAGES {
        let name_uppercase = lang.name.bytes().fold(String::new(), |mut acc, ch| {
            if ch.is_ascii_alphanumeric() {
                acc.push(ch.to_ascii_uppercase() as char);
            } else if !acc.ends_with('_') {
                acc.push('_');
            }
            acc
        });

        let mut builder = GraphBuilder::new();
        for s in lang.states {
            builder.declare_root(s.name);
        }
        for state in lang.states {
            for rule in state.rules {
                builder.parse(state.name, rule);
            }
        }
        builder.finalize();

        _ = write!(
            output,
            "\
/**
---
title: {}
config:
  layout: elk
  elk:
    considerModelOrder: NONE
---
{}
**/
",
            lang.name,
            builder.format_as_mermaid()
        );

        for (h, cs) in builder.extract_charsets() {
            _ = write!(
                output,
                "#[rustfmt::skip] const LANG_{}_CHARSET_{}: &[u16; 16] = &[",
                name_uppercase, h.0,
            );
            for lo in 0..16 {
                if lo > 0 {
                    _ = write!(output, ", ");
                }
                let mut u = 0u16;
                for hi in 0..16 {
                    u |= (cs[hi * 16 + lo] as u16) << hi;
                }
                _ = write!(output, "0x{u:04x}");
            }
            _ = writeln!(output, "];");
        }

        for (h, s) in builder.extract_strings() {
            _ = write!(
                output,
                "#[rustfmt::skip] const LANG_{}_STRING_{}: *const u8 = [",
                name_uppercase, h.0,
            );
            _ = write!(output, "{}", s.len());
            for &c in s.as_bytes() {
                _ = write!(output, ", 0x{:02x}", c);
            }
            _ = writeln!(output, "].as_ptr();");
        }

        _ = write!(
            output,
            "\
#[rustfmt::skip] pub const LANG_{name_uppercase}: &Language = &Language {{
    name: {name:?},
    filenames: &{filenames:?},
    transitions: &[
",
            name = lang.name,
            name_uppercase = name_uppercase,
            filenames = lang.filenames,
        );

        for t in builder.extract_transitions() {
            let test = match &t.test {
                GraphTest::Chars(usize::MAX) => "Chars(usize::MAX)".to_string(),
                GraphTest::Chars(n) => {
                    format!("Chars({n})")
                }
                GraphTest::Charset(cs) => {
                    format!("Charset(LANG_{}_CHARSET_{})", name_uppercase, cs.0)
                }
                GraphTest::Prefix(s) => {
                    format!("Prefix(LANG_{}_STRING_{})", name_uppercase, s.0)
                }
                GraphTest::PrefixInsensitive(s) => {
                    format!("PrefixInsensitive(LANG_{}_STRING_{})", name_uppercase, s.0)
                }
            };
            let action = match &t.dst {
                GraphAction::Jump(dst) => format!("Jump({})", dst.0),
                GraphAction::Push(dst) => format!("Push({})", dst.0),
                GraphAction::Pop(count) => format!("Pop({})", count),
                GraphAction::Loop(dst) => format!("Loop({})", dst.0),
                GraphAction::Fallback => unreachable!(),
            };
            _ = writeln!(output, "        t({test}, {kind:?}, {action}),", kind = t.kind,);
        }

        _ = write!(output, "    ],\n}};\n\n");
    }

    _ = write!(output, "#[rustfmt::skip] pub const LANGUAGES: &[&Language] = &[");
    for lang in LANGUAGES {
        let name_uppercase: String = lang.name.chars().fold(String::new(), |mut acc, ch| {
            if ch.is_whitespace() || ch.is_control() {
                if !acc.ends_with('_') {
                    acc.push('_');
                }
            } else {
                for up in ch.to_uppercase() {
                    acc.push(up);
                }
            }
            acc
        });
        _ = writeln!(output, "    LANG_{name_uppercase},");
    }
    _ = writeln!(output, "];");

    output
}
