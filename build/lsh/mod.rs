//! This file takes a [`LanguageDefinition`] which describes syntax highlighting rules
//! for a language via a list of regular expressions that result in
//! * a highlight kind (comment, string, number, etc.)
//! * a push/pop action of another state (allows for nesting languages, such as in Markdown)
//!
//! It then transforms the definition into a list of [`WipState`], which are directions
//! to our custom DFA engine. The engine is very simple to reduce binary size.
//! Each defined state represents a root. Each additional state represents one step in
//! the regular expression. The difference between the two is that the root states will
//! seek to the next possible occurrence of any of the defined regular expressions,
//! whereas the additional states will try to match the next character without seeking.
//! If it doesn't match, it will fall back to the next possible defined regular expression.

mod compiler;
mod definitions;
mod handles;

use std::fmt::Write as _;

use compiler::*;
use definitions::*;

pub fn generate() -> String {
    let mut output = String::new();

    output.push_str(
        "\
// This file is generated by build.rs. Do not edit it manually.

pub struct Language {
    pub name: &'static str,
    pub filenames: &'static [&'static str],
    pub strings: &'static [&'static str],
    pub charsets: &'static [[u16; 16]],
    pub instructions: &'static [u32],
}

impl PartialEq for Language {
    fn eq(&self, other: &Self) -> bool {
        std::ptr::eq(self, other)
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum HighlightKind {
    Black,
    Red,
    Green,
    Yellow,
    Blue,
    Magenta,
    Cyan,
    White,
    BrightBlack,
    BrightRed,
    BrightGreen,
    BrightYellow,
    BrightBlue,
    BrightMagenta,
    BrightCyan,
    BrightWhite,

    Other,
    Comment,
    Number,
    String,
    Variable,
    Operator,
    Keyword,
    Method,
}

impl HighlightKind {
    #[inline]
    pub const fn as_usize(self) -> usize {
        unsafe { std::mem::transmute::<HighlightKind, u8>(self) as usize }
    }

    #[inline]
    pub const unsafe fn from_usize(value: usize) -> Self {
        debug_assert!(value <= Self::Method.as_usize());
        unsafe { std::mem::transmute::<u8, HighlightKind>(value as u8) }
    }
}

#[derive(Debug, Clone, Copy)]
pub enum Register {
    Zero,
    ProgramCounter,
    ProcedureStart,
    InputOffset,
    HighlightStart,
    HighlightKind,

    #[allow(clippy::upper_case_acronyms)]
    COUNT,
}

#[allow(dead_code)]
pub type Registers = [u32; Register::COUNT as usize];

",
    );

    for lang in LANGUAGES {
        let name_uppercase = lang.name.bytes().fold(String::new(), |mut acc, ch| {
            if ch.is_ascii_alphanumeric() {
                acc.push(ch.to_ascii_uppercase() as char);
            } else if !acc.ends_with('_') {
                acc.push('_');
            }
            acc
        });

        let mut builder = Compiler::new();
        for s in lang.states {
            builder.declare_root(s.name);
        }
        for state in lang.states {
            for rule in state.rules {
                builder.parse(state.name, rule);
            }
        }
        let assembly = builder.compile();

        _ = write!(
            output,
            "\
/**
---
title: {}
config:
  layout: elk
  elk:
    considerModelOrder: NONE
---
{}
**/
#[rustfmt::skip] pub const LANG_{name_uppercase}: &Language = &Language {{
    name: {name:?},
    filenames: &{filenames:?},
    strings: &[
",
            lang.name,
            builder.format_as_mermaid(),
            name = lang.name,
            name_uppercase = name_uppercase,
            filenames = lang.filenames,
        );

        for s in builder.strings() {
            _ = writeln!(output, "        {s:?},");
        }

        output.push_str("    ],\n    charsets: &[\n");

        for cs in builder.charsets() {
            output.push_str("        [");
            for lo in 0..16 {
                if lo > 0 {
                    output.push_str(", ");
                }
                let mut u = 0u16;
                for hi in 0..16 {
                    u |= (cs[hi * 16 + lo] as u16) << hi;
                }
                _ = write!(output, "0x{u:04x}");
            }
            output.push_str("],\n");
        }

        output.push_str("    ],\n    instructions: &[\n");

        let line_num_width = assembly.len().ilog10() as usize + 1;
        for (i, op) in assembly.into_iter().enumerate() {
            _ = writeln!(
                output,
                "        {op:#010x}, // {i:>line_num_width$}:  {mnemonic}",
                op = op.encode(),
                mnemonic = op.mnemonic()
            );
        }

        output.push_str("    ],\n};\n\n");
    }

    output.push_str("#[rustfmt::skip] pub const LANGUAGES: &[&Language] = &[");
    for lang in LANGUAGES {
        let name_uppercase: String = lang.name.chars().fold(String::new(), |mut acc, ch| {
            if ch.is_whitespace() || ch.is_control() {
                if !acc.ends_with('_') {
                    acc.push('_');
                }
            } else {
                for up in ch.to_uppercase() {
                    acc.push(up);
                }
            }
            acc
        });
        _ = writeln!(output, "    LANG_{name_uppercase},");
    }
    output.push_str("];");

    output
}
