//! This file takes a [`LanguageDefinition`] which describes syntax highlighting rules
//! for a language via a list of regular expressions that result in
//! * a highlight kind (comment, string, number, etc.)
//! * a push/pop action of another state (allows for nesting languages, such as in Markdown)
//!
//! It then transforms the definition into a list of [`WipState`], which are directions
//! to our custom DFA engine. The engine is very simple to reduce binary size.
//! Each defined state represents a root. Each additional state represents one step in
//! the regular expression. The difference between the two is that the root states will
//! seek to the next possible occurrence of any of the defined regular expressions,
//! whereas the additional states will try to match the next character without seeking.
//! If it doesn't match, it will fall back to the next possible defined regular expression.

mod compiler;
mod definitions;
mod handles;

use std::fmt::Write as _;

use compiler::*;
use definitions::*;

pub fn generate() -> String {
    let mut output = String::new();

    output.push_str(
        "\
// This file is generated by build.rs. Do not edit it manually.

use std::ops::RangeInclusive;

use HighlightKind::*;
use Instruction::*;

pub struct Language {
    pub name: &'static str,
    pub filenames: &'static [&'static str],
    pub instructions: &'static [Instruction],
}

impl PartialEq for Language {
    fn eq(&self, other: &Self) -> bool {
        std::ptr::eq(self, other)
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum HighlightKind {
    Black,
    Red,
    Green,
    Yellow,
    Blue,
    Magenta,
    Cyan,
    White,
    BrightBlack,
    BrightRed,
    BrightGreen,
    BrightYellow,
    BrightBlue,
    BrightMagenta,
    BrightCyan,
    BrightWhite,

    Other,
    Comment,
    Number,
    String,
    Variable,
    Operator,
    Keyword,
    Method,
}

impl HighlightKind {
    pub const fn as_usize(self) -> usize {
        unsafe { std::mem::transmute::<HighlightKind, u8>(self) as usize }
    }

    pub const unsafe fn from_usize(value: usize) -> Self {
        debug_assert!(value <= Method.as_usize());
        unsafe { std::mem::transmute::<u8, HighlightKind>(value as u8) }
    }
}

pub const REG_ZERO: u8 = 0;
pub const REG_PROGRAM_COUNTER: u8 = 1;
pub const REG_INPUT_OFFSET: u8 = 2;
pub const REG_HIGHLIGHT_START: u8 = 3;
pub const REG_HIGHLIGHT_KIND: u8 = 4;

pub type Registers = [usize; 5];

#[derive(Debug, Clone)]
pub enum Instruction {
    // .0 (reg) = .1 (reg) + .2 (constant)
    // Note that this allows for jumps as well, by manipulating REG_PROGRAM_COUNTER.
    Add(u8, u8, usize),

    // Typical call/ret instructions.
    // The VM takes care of saving the return address.
    Call(u16),
    Return,

    // Test (and consume) the given character(s) in `.1`.
    // If the test fails, jump to `.0`.
    JumpIfNotMatchCharset(u16, CharsetHandle),
    JumpIfNotMatchPrefix(u16, StringHandle),
    JumpIfNotMatchPrefixInsensitive(u16, StringHandle),

    // Flush the current HighlightKind to the output.
    FlushHighlight,

    // Check if we're at the end and exit if so.
    SuspendOpportunity,
}

",
    );

    for lang in LANGUAGES {
        let name_uppercase = lang.name.bytes().fold(String::new(), |mut acc, ch| {
            if ch.is_ascii_alphanumeric() {
                acc.push(ch.to_ascii_uppercase() as char);
            } else if !acc.ends_with('_') {
                acc.push('_');
            }
            acc
        });

        let mut builder = Compiler::new();
        for s in lang.states {
            builder.declare_root(s.name);
        }
        for state in lang.states {
            for rule in state.rules {
                builder.parse(state.name, rule);
            }
        }
        let assembly = builder.compile();

        _ = write!(
            output,
            "\
/**
---
title: {}
config:
  layout: elk
  elk:
    considerModelOrder: NONE
---
{}
**/
",
            lang.name,
            builder.format_as_mermaid()
        );

        for (h, s) in &assembly.strings {
            _ = write!(
                output,
                "#[rustfmt::skip] const LANG_{}_STRING_{}: *const u8 = [",
                name_uppercase, h.0,
            );
            _ = write!(output, "{}", s.len());
            for &c in s.as_bytes() {
                _ = write!(output, ", 0x{:02x}", c);
            }
            _ = writeln!(output, "].as_ptr();");
        }

        for (h, cs) in &assembly.charsets {
            _ = write!(
                output,
                "#[rustfmt::skip] const LANG_{}_CHARSET_{}: &[u16; 16] = &[",
                name_uppercase, h.0,
            );
            for lo in 0..16 {
                if lo > 0 {
                    _ = write!(output, ", ");
                }
                let mut u = 0u16;
                for hi in 0..16 {
                    u |= (cs[hi * 16 + lo] as u16) << hi;
                }
                _ = write!(output, "0x{u:04x}");
            }
            _ = writeln!(output, "];");
        }

        _ = write!(
            output,
            "\
#[rustfmt::skip] pub const LANG_{name_uppercase}: &Language = &Language {{
    name: {name:?},
    filenames: &{filenames:?},
    instructions: &[
",
            name = lang.name,
            name_uppercase = name_uppercase,
            filenames = lang.filenames,
        );

        for op in &assembly.instructions {
            match op {
                Instruction::JumpIfNotMatchCharset(addr, h) => {
                    _ = writeln!(
                        output,
                        "        JumpIfNotMatchCharset({addr}, LANG_{name_uppercase}_CHARSET_{h}),"
                    );
                }
                Instruction::JumpIfNotMatchPrefix(addr, h) => {
                    _ = writeln!(
                        output,
                        "        JumpIfNotMatchPrefix({addr}, LANG_{name_uppercase}_STRING_{h}),"
                    );
                }
                Instruction::JumpIfNotMatchPrefixInsensitive(addr, h) => {
                    _ = writeln!(
                        output,
                        "        JumpIfNotMatchPrefixInsensitive({addr}, LANG_{name_uppercase}_STRING_{h}),"
                    );
                }
                _ => {
                    _ = writeln!(output, "        {op:?},");
                }
            }
        }

        _ = write!(output, "    ],\n}};\n\n");
    }

    _ = write!(output, "#[rustfmt::skip] pub const LANGUAGES: &[&Language] = &[");
    for lang in LANGUAGES {
        let name_uppercase: String = lang.name.chars().fold(String::new(), |mut acc, ch| {
            if ch.is_whitespace() || ch.is_control() {
                if !acc.ends_with('_') {
                    acc.push('_');
                }
            } else {
                for up in ch.to_uppercase() {
                    acc.push(up);
                }
            }
            acc
        });
        _ = writeln!(output, "    LANG_{name_uppercase},");
    }
    _ = writeln!(output, "];");

    output
}
