// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

//! This file takes a [`LanguageDefinition`] which describes syntax highlighting rules
//! for a language via a list of regular expressions that result in
//! * a highlight kind (comment, string, number, etc.)
//! * a push/pop action of another state (allows for nesting languages, such as in Markdown)
//!
//! It then transforms the definition into a list of [`WipState`], which are directions
//! to our custom DFA engine. The engine is very simple to reduce binary size.
//! Each defined state represents a root. Each additional state represents one step in
//! the regular expression. The difference between the two is that the root states will
//! seek to the next possible occurrence of any of the defined regular expressions,
//! whereas the additional states will try to match the next character without seeking.
//! If it doesn't match, it will fall back to the next possible defined regular expression.

#![feature(allocator_api)]
#![allow(irrefutable_let_patterns)]

mod compiler;
mod definitions;

use compiler::*;
use definitions::*;
use stdext::arena::scratch_arena;

const SRC: &str = include_str!("../../../lsh/COMMIT_EDITMSG.lsh");

pub fn generate() -> CompileResult<String> {
    let arena = scratch_arena(None);
    let mut compiler = Compiler::new(&arena);
    compiler.parse(SRC)?;
    Ok(compiler.as_mermaid())

    /*
    let mut output = String::new();

    output.push_str(
        "\
// This file is generated by build.rs. Do not edit it manually.

pub struct Language {
    pub name: &'static str,
    pub filenames: &'static [&'static str],
    pub strings: &'static [&'static str],
    pub charsets: &'static [[u16; 16]],
    pub instructions: &'static [u32],
}

impl PartialEq for Language {
    fn eq(&self, other: &Self) -> bool {
        std::ptr::eq(self, other)
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum HighlightKind {
    Black,
    Red,
    Green,
    Yellow,
    Blue,
    Magenta,
    Cyan,
    White,
    BrightBlack,
    BrightRed,
    BrightGreen,
    BrightYellow,
    BrightBlue,
    BrightMagenta,
    BrightCyan,
    BrightWhite,

    Other,
    Comment,
    Number,
    String,
    Variable,
    Operator,
    Keyword,
    Method,
}

impl HighlightKind {
    #[inline]
    pub const fn as_usize(self) -> usize {
        unsafe { std::mem::transmute::<HighlightKind, u8>(self) as usize }
    }

    /// # Safety
    /// Don't pass the wrong thing you dummy.
    #[inline]
    pub const unsafe fn from_usize(value: usize) -> Self {
        debug_assert!(value <= Self::Method.as_usize());
        unsafe { std::mem::transmute::<u8, HighlightKind>(value as u8) }
    }
}

#[repr(C)]
#[derive(Default, Clone, Copy)]
pub struct Registers {
    pub zero: u32, // Zero
    pub pc: u32,   // ProgramCounter
    pub ps: u32,   // ProcedureStart
    pub off: u32,  // InputOffset
    pub hs: u32,   // HighlightStart
    pub hk: u32,   // HighlightKind
}

",
    );

        for lang in LANGUAGES {
            let scratch = scratch_arena(None);
            let name_uppercase = lang.name.bytes().fold(String::new(), |mut acc, ch| {
                if ch.is_ascii_alphanumeric() {
                    acc.push(ch.to_ascii_uppercase() as char);
                } else if !acc.ends_with('_') {
                    acc.push('_');
                }
                acc
            });

            let mut frontend = Frontend::new(&scratch);
            for s in lang.states {
                frontend.declare_root(s.name);
            }
            for state in lang.states {
                for rule in state.rules {
                    frontend.parse(state.name, rule);
                }
            }
            frontend.finalize();

            let mut backend = Backend::new();
            backend.compile(&frontend);

            _ = write!(
                output,
                "\
/**
---
title: {}
config:
  layout: elk
  elk:
    considerModelOrder: NONE
---
",
                lang.name,
            );

            {
                _ = writeln!(&mut output, "flowchart TD");

                frontend.visit_graph(|n| {});

                /*let mut iter = self.transitions.iter().peekable();
                while let Some(t) = iter.next() {
                    let src_offset = self.states[t.src].offset;
                    let dst_offset = self.states[match &t.dst {
                        GraphAction::Jump(dst) | GraphAction::Push(dst) | GraphAction::Loop(dst) => {
                            *dst
                        }
                        GraphAction::Pop(_) => StateHandle(0),
                        GraphAction::Fallback => unreachable!(),
                    }]
                    .offset;

                    if !visited[t.src.0] {
                        visited[t.src.0] = true;

                        let s = &self.states[t.src];
                        if let Some(name) = s.name {
                            _ = writeln!(&mut output, "    {src_offset}[\"{src_offset} ({name})\"]");
                        }
                    }

                    let label = match t.test {
                        GraphTest::Chars(usize::MAX) => "Chars(Line)".to_string(),
                        GraphTest::Chars(n) => format!("Chars({n})"),
                        GraphTest::Charset(c) => format!("Charset({:?})", &self.charsets[c]),
                        GraphTest::Prefix(s) => {
                            let mut label = String::new();
                            _ = write!(label, "Prefix({}", &self.strings[s]);

                            while let Some(next) = iter.peek()
                                && let GraphTest::Prefix(next_s) = next.test
                                && next.dst == t.dst
                            {
                                _ = write!(label, ", {}", &self.strings[next_s]);
                                iter.next();
                            }

                            label.push(')');
                            label
                        }
                        GraphTest::PrefixInsensitive(s) => {
                            let mut label = String::new();
                            _ = write!(label, "PrefixInsensitive({}", &self.strings[s]);

                            while let Some(next) = iter.peek()
                                && let GraphTest::PrefixInsensitive(next_s) = next.test
                                && next.dst == t.dst
                            {
                                _ = write!(label, ", {}", &self.strings[next_s]);
                                iter.next();
                            }

                            label.push(')');
                            label
                        }
                    };

                    let dst_str = match &t.dst {
                        GraphAction::Jump(_) => {
                            format!("{dst_offset}")
                        }
                        GraphAction::Push(dst) => {
                            format!(
                                "push{}[/\"{}\"/]",
                                src_offset << 16 | dst_offset,
                                self.states[*dst].name.unwrap()
                            )
                        }
                        GraphAction::Pop(_) => {
                            format!("pop{}@{{ shape: stop }}", src_offset << 16)
                        }
                        GraphAction::Loop(_) => {
                            format!("{dst_offset}")
                        }
                        GraphAction::Fallback => unreachable!(),
                    };

                    let label = {
                        let mut res = String::with_capacity(label.len());
                        for c in label.chars() {
                            match c {
                                '\t' => res.push_str(r#"\\t"#),
                                '"' => res.push_str("&quot;"),
                            '\\' => res.push_str(r#"\\"#),
                            _ => res.push(c),
                        }
                    }
                    res
                };
                _ = writeln!(
                    &mut output,
                    "    {src_offset} -->|\"{label}<br/>{kind:?}\"| {dst_str}",
                    kind = t.kind,
                );
            }*/
            }

            _ = write!(
                output,
                "\
    **/
    #[rustfmt::skip] pub const LANG_{name_uppercase}: &Language = &Language {{
        name: {name:?},
        filenames: &{filenames:?},
        strings: &[
",
            name = lang.name,
            name_uppercase = name_uppercase,
            filenames = lang.filenames,
        );
        for s in backend.strings() {
            _ = writeln!(output, "        {s:?},");
        }

        output.push_str("    ],\n    charsets: &[\n");

        for cs in backend.charsets() {
            output.push_str("        [");
            for lo in 0..16 {
                if lo > 0 {
                    output.push_str(", ");
                }
                let mut u = 0u16;
                for hi in 0..16 {
                    u |= (cs[hi * 16 + lo] as u16) << hi;
                }
                _ = write!(output, "0x{u:04x}");
            }
            output.push_str("],\n");
        }

        output.push_str("    ],\n    instructions: &[\n");

        let assembly = backend.instructions();
        let line_num_width = assembly.len().ilog10() as usize + 1;
        for (i, op) in assembly.iter().enumerate() {
            _ = writeln!(
                output,
                "        {op:#010x}, // {i:>line_num_width$}:  {mnemonic}",
    op = op.encode(),
                    mnemonic = op.mnemonic()
                );
            }

            output.push_str("    ],\n};\n\n");
        }

        output.push_str("#[rustfmt::skip] pub const LANGUAGES: &[&Language] = &[");
        for lang in LANGUAGES {
            let name_uppercase: String = lang.name.chars().fold(String::new(), |mut acc, ch| {
                if ch.is_whitespace() || ch.is_control() {
                    if !acc.ends_with('_') {
                        acc.push('_');
                    }
                } else {
                    for up in ch.to_uppercase() {
                        acc.push(up);
                    }
                }
                acc
            });
            _ = writeln!(output, "    LANG_{name_uppercase},");
        }
        output.push_str("];");

        output
    */
}
