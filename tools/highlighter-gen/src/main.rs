//! This file takes a [`LanguageDefinition`] which describes syntax highlighting rules
//! for a language via a list of regular expressions that result in
//! * a highlight kind (comment, string, number, etc.)
//! * a push/pop action of another state (allows for nesting languages, such as in Markdown)
//!
//! It then transforms the definition into a list of [`WipState`], which are directions
//! to our custom DFA engine. The engine is very simple to reduce binary size.
//! Each defined state represents a root. Each additional state represents one step in
//! the regular expression. The difference between the two is that the root states will
//! seek to the next possible occurrence of any of the defined regular expressions,
//! whereas the additional states will try to match the next character without seeking.
//! If it doesn't match, it will fall back to the next possible defined regular expression.

mod definitions;
mod transformer;

use std::fmt::Write as _;
use std::io::Write as _;

use indoc::{indoc, writedoc};

use crate::definitions::*;
use crate::transformer::*;

fn main() {
    let mut output = String::new();
    output.push_str(indoc! {
        r#"
        // This file is auto-generated by the highlighter-gen tool.
        // Do not edit this file directly.

        use std::ops::RangeInclusive;

        use Action::*;
        use HighlightKind::*;
        use Test::*;

        pub struct Language {
            pub name: &'static str,
            pub extensions: &'static [&'static str],
            pub charsets: &'static [&'static [u8; 256]],
            pub states: &'static [&'static [Transition<'static>]],
        }

        pub struct Transition<'a> {
            pub test: Test<'a>,
            pub kind: Option<HighlightKind>,
            pub action: Action,
        }

        pub enum Test<'a> {
            Chars(usize),
            Charset(usize),
            Prefix(&'a str),
            PrefixInsensitive(&'a str),
        }

        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq)]
        pub enum HighlightKind {
            #[default]
            Other,
            Comment,
            Number,
            String,
            Variable,
            Operator,
            Keyword,
            Method,
        }

        pub enum Action {
            Change(u8),
            Push(u8),
            Pop(u8),
        }

        const fn t<'a>(test: Test<'a>, kind: Option<HighlightKind>, action: Action) -> Transition<'a> {
            Transition { test, kind, action }
        }

        "#
    });

    for lang in LANGUAGES {
        let name_uppercase = lang.name.to_ascii_uppercase();
        let mut builder = GraphBuilder::new();

        for s in lang.states {
            builder.add_root(s.name);
        }

        for (root, state) in lang.states.iter().enumerate() {
            for rule in state.rules {
                builder.parse(root, rule);
            }
        }

        builder.finalize();

        _ = writedoc!(
            output,
            "
            /**
            ---
            title: {}
            config:
              layout: elk
            ---
            {}
            **/
            ",
            lang.name,
            builder.format_as_mermaid()
        );

        _ = writedoc!(
            output,
            r#"
            #[rustfmt::skip]
            pub const LANG_{name_uppercase}: &Language = &Language {{
                name: "{name}",
                extensions: &{extensions:?},
                charsets: &[
            "#,
            name = lang.name,
            name_uppercase = name_uppercase,
            extensions = lang.extensions,
        );

        for cs in builder.charsets() {
            _ = write!(output, "        &[",);
            for (i, bit) in cs.bits().iter().enumerate() {
                if i > 0 {
                    _ = write!(output, ", ");
                }
                _ = write!(output, "{}", *bit as u8);
            }
            _ = writeln!(output, "],");
        }

        _ = write!(output, "    ],\n    states: &[\n");

        for state in builder.states() {
            let state = state.borrow();

            _ = writeln!(output, r#"        &["#);

            for t in &state.transitions {
                let test = match &t.test {
                    GraphTest::Chars(usize::MAX) => "Chars(usize::MAX)".to_string(),
                    GraphTest::Chars(n) => {
                        format!("Chars({n})")
                    }
                    GraphTest::Charset(cs) => {
                        format!("Charset({})", cs.id())
                    }
                    GraphTest::Prefix(s) => {
                        format!("Prefix(r#\"{s}\"#)")
                    }
                    GraphTest::PrefixInsensitive(s) => {
                        format!("PrefixInsensitive(r#\"{s}\"#)")
                    }
                };
                let action = match &t.action {
                    GraphAction::Change(next) => format!("Change({})", next.borrow().id),
                    GraphAction::Push(next) => format!("Push({})", next.borrow().id),
                    GraphAction::Pop(count) => format!("Pop({})", count),
                };
                _ = writeln!(
                    output,
                    r#"            t({test}, {kind:?}, {action}),"#,
                    kind = t.kind,
                );
            }

            _ = writeln!(output, r#"        ],"#);
        }

        _ = writedoc!(
            output,
            r#"
                ],
            }};

            "#
        );
    }

    _ = writedoc!(
        output,
        r#"
        #[rustfmt::skip]
        pub const LANGUAGES: &[&Language] = &[
        "#
    );
    for lang in LANGUAGES {
        let name_uppercase = lang.name.to_ascii_uppercase();
        _ = writeln!(output, "    LANG_{name_uppercase},");
    }
    _ = writeln!(output, "];");

    _ = std::io::stdout().write_all(output.as_bytes());
}
